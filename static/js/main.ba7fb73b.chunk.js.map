{"version":3,"sources":["boggle-solver.js","logo.svg","dictionary-utilities.js","App.js","reportWebVitals.js","index.js"],"names":["code","onmessage","e","data","startingPoints","boggleBoardValues","wordTree","findWords","point","currentNode","ignorePoints","words","nextPoints","getNextPoints","forEach","nextPoint","letter","toLowerCase","nextNode","children","find","child","value","word","push","length","concat","boardDimension","Math","sqrt","Object","keys","coordinates","split","map","coordinate","x","y","addNextPoint","includes","startingPoint","postMessage","toString","substring","indexOf","lastIndexOf","blob","Blob","type","workerScript","URL","createObjectURL","TreeNode","addChild","node","parent","getChild","boardDimensionArray","Array","ALPHABET","dictionary","App","useState","dictionaryLoaded","setDictionaryLoaded","useEffect","then","useForm","errors","handleSubmit","register","setValue","hasErrors","setWords","solving","setSolving","onInput","currentField","currentTarget","name","c","BOARD_DIMENSION","runButton","document","getElementById","disabled","focus","nextField","querySelector","join","select","className","autoComplete","onSubmit","startTime","Date","now","characters","reduce","chars","key","wordSet","letters","regex","RegExp","filter","test","createWordSet","wordSetFinishTime","console","log","tree","i","character","isWord","undefined","createWordTree","cpuCount","navigator","hardwareConcurrency","taskCount","floor","boggleBoardPoints","workerCount","shutdownWorker","worker","terminate","isLastWorker","startingPointCount","j","Worker","sort","a","b","localeCompare","onerror","error","rowIndex","columnIndex","maxLength","ref","required","pattern","onClick","values","boardValues","random","createRandomBoard","shouldValidate","id","title","alt","src","logo","Fragment","reportWebVitals","onPerfEntry","Function","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.ba7fb73b.chunk.js","sourcesContent":["/**\n * Not your typical Web Worker code. I first attempted to place this file in the public directory but my\n * app was not finding this file. So I found a nice hack around using web workers with create-react-app.\n * \n * https://github.com/facebook/create-react-app/issues/1277\n */\nconst workerCode = () => {\n\n  onmessage = function(e) {\n\n    const { \n      startingPoints,    // The starting points this worker is responsible for solving for\n      boggleBoardValues, // All of the boggle game board letters\n      wordTree           // The tree data structure of all of the possible words we could care about given the letters on the game board\n    } = e.data;\n\n    /**\n     * Recursive function to find a word starting at the given point on the board\n     * \n     * @param {String} point Current point on the game board\n     * @param {Object} currentNode The current node in the tree\n     * @param {Array} ignorePoints Points that we are not allowed to travel to next (the current path's points)\n     */\n    const findWords = (point, currentNode, ignorePoints = []) => {\n      let words = [];\n\n      const nextPoints = getNextPoints(point, ignorePoints);\n      nextPoints.forEach(nextPoint => {\n\n        const letter = boggleBoardValues[nextPoint].toLowerCase();\n        const nextNode = currentNode.children.find(child => child.value === letter);\n\n        if (nextNode) {\n          // If we found a word, be sure to add it!\n          if (nextNode.word) {\n            words.push(nextNode.word);\n          }\n          // If the next node has children then we should keep searching for more words down the path\n          if (nextNode.children.length > 0) {\n            words = words.concat(findWords(nextPoint, nextNode, ignorePoints.concat(point)));\n          }\n        }\n      });\n      return words;\n    };\n\n    const boardDimension = Math.sqrt(Object.keys(boggleBoardValues).length);\n\n    /**\n     * Retrieves all of the points that surround the given point that are NOT in ignorePoints\n     * \n     * @param {String} point Point of reference to get the next points from\n     * @param {Array} ignorePoints Points to ignore (the current path's points)\n     */\n    const getNextPoints = (point, ignorePoints) => {\n      const coordinates = point.split(',').map(coordinate => +coordinate);\n      const x = coordinates[0];\n      const y = coordinates[1];\n\n      const nextPoints = [];\n      if (x < boardDimension - 1) {\n        addNextPoint(`${x + 1},${y}`, nextPoints, ignorePoints);\n        if (y > 0) {\n          addNextPoint(`${x + 1},${y - 1}`, nextPoints, ignorePoints);\n        }\n        if (y < boardDimension - 1) {\n          addNextPoint(`${x + 1},${y + 1}`, nextPoints, ignorePoints);\n        }\n      }\n      if (y < boardDimension - 1) {\n        addNextPoint(`${x},${y + 1}`, nextPoints, ignorePoints);\n      }\n      if (x > 0) {\n        addNextPoint(`${x - 1},${y}`, nextPoints, ignorePoints);\n        if (y > 0) {\n          addNextPoint(`${x - 1},${y - 1}`, nextPoints, ignorePoints);\n        }\n        if (y < boardDimension -1) {\n          addNextPoint(`${x - 1},${y + 1}`, nextPoints, ignorePoints);\n        }\n      }\n      if (y > 0) {\n        addNextPoint(`${x},${y - 1}`, nextPoints, ignorePoints);\n      }\n      return nextPoints;\n    }\n\n    /**\n     * Helper function to add the next point to the array of next points only if it does not exist within the ignorePoints array\n     * \n     * @param {String} nextPoint The next point to add\n     * @param {Array} nextPoints  Array of the next points after the current point\n     * @param {Array} ignorePoints Array of points to ignore\n     */\n    const addNextPoint = (nextPoint, nextPoints, ignorePoints) =>\n      !ignorePoints.includes(nextPoint) && nextPoints.push(nextPoint);\n\n    // Traverse Boggle board finding words starting at each starting point.\n    let words = [];\n    startingPoints.forEach(startingPoint => {\n      \n      // First see if ANY words start with the starting point's letter\n      const letter = boggleBoardValues[startingPoint].toLowerCase();\n      const nextNode = wordTree.children.find(child => child.value === letter);\n      if (nextNode) {\n        words = words.concat(findWords(startingPoint, nextNode));\n      }\n    });\n\n    // Send the words back to the main thread\n    postMessage(words);\n  };\n}\n\n// The following is the \"hacked\" code that will allow calling a web worker from within my main app. The things we do for parallelism.\nlet code = workerCode.toString();\ncode = code.substring(code.indexOf(\"{\")+1, code.lastIndexOf(\"}\"));\n\nconst blob = new Blob([code], { type: 'application/javascript' });\nconst workerScript = URL.createObjectURL(blob);\n\nexport default workerScript;\n","export default __webpack_public_path__ + \"static/media/logo.42627872.svg\";","/**\n * Reduces the given dictionary by filtering on words that are at least 3 characters long and only contain the given letters\n * \n * @param {Object} dictionary Object that contains ALL of the words in the dictionary\n * @param {String} letters String of letters found on the Boggle board\n */\nexport const createWordSet = (dictionary, letters) => {\n  const regex = new RegExp('\\\\b[' + letters + ']{3,}\\\\b');\n  return dictionary['words'].filter(word => regex.test(word.toLowerCase()));\n}\n\n/**\n * Creates a tree data structure that contains each word in the given set of words. Each node in the tree represents a letter from a word.\n * \n * Tree structure for BOA, BOAS, BOAR, BOARD, BOARS, BOARDS, BOG, BOGGLE, BOGS\n *         S*\n *        /\n *       G* - G - L - E*\n *      /\n * B - O   S*    S*\n *      \\ /    /\n *       A* - R* - D* - S*\n * \n * @param {Array} wordSet The set of words to create the tree strucutre for\n */\nexport const createWordTree = (wordSet) => {\n  const tree = TreeNode(); // Create a tree with an empty root node\n  wordSet.forEach(word => {\n    let currentNode = tree;\n    for (let i = 0; i < word.length; i++) {\n        const character = word[i];\n        const isWord = i === word.length - 1; // The last character in the word indicates we have found a word\n\n        const child = getChild(currentNode, character);\n        if (child) {\n            if (isWord) {\n                child.word = word;\n            }\n            currentNode = child;\n        } else {\n            currentNode = addChild(currentNode, character, isWord ? word : undefined);\n        }\n    }\n  });\n  return tree;\n};\n\n/**\n * A datastructure to represent a node of a tree (and since navigation is essentially through a linked list approach,\n * this is all that is needed to store an entire tree). Since this is passed to a web worker I was unable to make this\n * a class nor a function, and instead created a function that returns a plain Object.\n * \n * @param {String} value Letter at the tree node\n * @param {String} word If this tree node completes a word, then this is the word\n */\nconst TreeNode = (value, word) => ({\n    value: value && value.toLowerCase(),\n    word,\n    children: []\n});\n\n/**\n * Adds a new TreeNode as a child of the given node\n * \n * @param {Object} node Tree node to add a child to\n * @param {String} value Value of the new child tree node\n * @param {String} word If the child tree node completes a word, then this is the word\n */\nconst addChild = (node, value, word) => {\n    const child = TreeNode(value, word);\n    child.parent = node;\n    node.children.push(child);\n    return child;\n};\n\n/**\n * Finds a child of the given node who's value matches the given value\n * \n * @param {Object} node Node whose children to search\n * @param {String} value Value to find child for\n */\nconst getChild = (node, value) =>\n    node.children.find(child => child.value === value);","import React, { useEffect, useState } from 'react';\nimport { useForm } from 'react-hook-form';\nimport workerScript from './boggle-solver';\nimport logo from './logo.svg';\nimport './App.css';\nimport { createWordSet, createWordTree } from './dictionary-utilities';\n\nconst BOARD_DIMENSION = 4;\nconst boardDimensionArray = [...Array(BOARD_DIMENSION).keys()];\n\nconst ALPHABET = 'abcdefghijklmnopqrstuvwxyz';\nlet dictionary = null;\n\n/**\n * Generates a double array of random board values.\n */\nconst createRandomBoard = () => {\n  let boardValues = [];\n  for (let i = 0; i < BOARD_DIMENSION; i++) {\n    boardValues[i] = [];\n    for (let j = 0; j < BOARD_DIMENSION; j++) {\n      boardValues[i][j] = ALPHABET[Math.floor(Math.random() * ALPHABET.length)];\n    }\n  }\n  return boardValues;\n};\n\nfunction App() {\n  /*\n   * Load the dictionary upon init of the page. This file is quite large so hopefully by the time the user has\n   * finished entering all of the values into the Boggle board, we have downloaded the massive dictionary.\n   * \n   * dictionary.json was modified based on words_alpha.txt found at https://github.com/dwyl/english-words\n   */\n  const [ dictionaryLoaded, setDictionaryLoaded ] = useState(false);\n  useEffect(() => {\n    import('./dictionary_en_US.json').then(data => {\n      dictionary = data;\n      setDictionaryLoaded(true);\n    })\n  }, []);\n\n  // Retrieve form data using react-hook-form.js\n  const { errors, handleSubmit, register, setValue } = useForm();\n  const hasErrors = Object.keys(errors).length > 0;\n\n  // Retrieve the words from the most recent solve\n  const [ words, setWords ] = useState();\n\n  /*\n   * Event handler to begin Boggle solver. The downside of hooks is that you can have huge functions to retain\n   * closure scope unless you pass in these setters as parameters. I took the former approach so bear with me.\n   */\n  const [ solving, setSolving ] = useState(false);\n  const onSubmit = boggleBoardValues => {\n    const startTime = Date.now();\n    setSolving(true);\n\n    // Reduce the words in the FULL dictionary to ones that only contain the Boggle letters\n    const characters = Object.keys(boggleBoardValues).reduce((chars, key) => chars += boggleBoardValues[key], '').toLowerCase();\n    const wordSet = createWordSet(dictionary, characters);\n    const wordSetFinishTime = Date.now();\n    console.log('Word Reduction: ' + (wordSetFinishTime - startTime) + ' ms');\n\n    /*\n     * Create Tree structure for those words. Each word will be added to the same tree structure where each\n     * node in the tree represents a character in a word. If a node marks the end of a word, a flag is added\n     * to that node by storing the word there (depicted below with *).\n     * \n     * Utilizing this data structure will allow us to terminate the traversal of the Boggle board if we reach\n     * a node that has no children.\n     *\n     *       G* - G - L - E*\n     *      /\n     * B - O\n     *      \\\n     *       A* - R* - D*\n     */\n    const wordTree = createWordTree(wordSet);\n    console.log('Word Tree Creation: ' + (Date.now() - wordSetFinishTime) + ' ms');\n\n    /*\n     * Hol up a minute. Before we venture into the main algorithm (found in boggle-solver.js) we are going to\n     * try something wild and run the algorithm in parallel using web workers. Each worker will be given a list\n     * of starting points on the Boggle board. So most of the code left in this method is just setting up which\n     * starting points to give to which web workers. There will be one web worker created for every CPU the\n     * machine has available.\n     */\n    const cpuCount = navigator.hardwareConcurrency;\n    const boggleSpaces = BOARD_DIMENSION * BOARD_DIMENSION;\n    const taskCount = Math.floor(boggleSpaces / cpuCount);\n    const boggleBoardPoints = Object.keys(boggleBoardValues);\n\n    // Common shutdown code that is needed upon success or error for the web workers\n    let workerCount = cpuCount;\n    const shutdownWorker = (worker) => {\n      worker.terminate();\n\n      const isLastWorker = --workerCount === 0;\n      if (isLastWorker)  {\n        setSolving(false);\n        console.log('Total Time: ' + (Date.now() - startTime) + ' ms');\n      }\n      return isLastWorker;\n    };\n\n    // Object to store the unique words that were found\n    const words = {};\n\n    // Assign starting points to each web worker\n    for (let i = 0; i < cpuCount; i++) {\n\n      // Determine which starting points (x,y) in the boggle board a web worker will process\n      const startingPoints = [];\n      const startingPointCount = taskCount + (i === cpuCount - 1 ? boggleSpaces % cpuCount : 0); // The last worker just gets the remainder\n      for (let j = 0; j < startingPointCount; j++) {\n        startingPoints.push(boggleBoardPoints[(i * taskCount) + j]);\n      }\n\n      // Create a web worker for the set of starting points\n      const worker = new Worker(workerScript);\n      worker.onmessage = (e) => {\n\n        // Add the words to our words set\n        e.data.forEach(word => words[word] = true);\n\n        // Shutdown the worker, and if it is the last worker let's update the words in state\n        if (shutdownWorker(worker)) {\n          setWords(Object.keys(words).sort((a,b) => a.localeCompare(b)));\n        }\n      };\n\n      worker.onerror = (e) => {\n        console.error('Error occurred solving Boggle board');\n        shutdownWorker(worker);\n      }\n\n      // Send the task to the worker\n      worker.postMessage({\n        startingPoints,\n        boggleBoardValues,\n        wordTree\n      });\n    }\n  };\n\n  // Event handler for filling out the board quickly (saved dev time :) )\n  const onRandom = () => {\n    const values = createRandomBoard();\n    for (let i = 0; i < values.length; i++) {\n      for (let j = 0; j < values[i].length; j++) {\n        setValue(`${i},${j}`, values[i][j], { shouldValidate: true });\n      }\n    }\n  };\n\n  // Event handler for changing focus after entering text on the board\n  const onInput = (e) => {\n    const currentField = e.currentTarget;\n    if (currentField.value) {\n      const coordinates = currentField.name.split(',').map(c => +c);\n      if (coordinates[0] === BOARD_DIMENSION - 1) {\n        if (coordinates[1] === BOARD_DIMENSION - 1) {\n          const runButton = document.getElementById('runButton');\n          if (!runButton.disabled) {\n            runButton.focus();\n          }\n          return;\n        }\n        coordinates[1] += 1;\n        coordinates[0] = 0;\n      } else {\n        coordinates[0] += 1;\n      }\n      const nextField = document.querySelector('input[name=\"'+coordinates.join()+'\"]');\n      nextField.focus();\n      nextField.select();\n    }\n  };\n\n  return (\n    <div className=\"app\">\n      <form\n        autoComplete=\"off\"\n        className=\"app-content\"\n        onSubmit={handleSubmit(onSubmit)}\n      >\n        <h1>Boggle Solver</h1>\n        {\n          boardDimensionArray.map((value, rowIndex) => \n            <div\n              className=\"game-row\"\n              key={rowIndex}\n            >\n              {\n                boardDimensionArray.map((value, columnIndex) =>\n                  <input\n                    autoComplete=\"off\"\n                    className=\"game-dice\"\n                    key={columnIndex}\n                    maxLength=\"1\"\n                    name={`${columnIndex},${rowIndex}`}\n                    onInput={onInput}\n                    ref={\n                      register({\n                        required: true,\n                        pattern: /[A-Za-z]/\n                      })\n                    }\n                    type=\"text\"\n                  />\n                )\n              }\n            </div>\n          )\n        }\n        <div className=\"button-bar\">\n          <div className=\"button-bar__button-container --right\">\n            <button\n              className=\"button-bar__random-button\"\n              onClick={onRandom}\n              type=\"button\"\n            >\n              Random\n            </button>\n          </div>\n          <div className=\"button-bar__button-container --left\">\n            <button\n              className=\"button-bar__run-button\"\n              disabled={hasErrors || !dictionaryLoaded}\n              id=\"runButton\"\n              title={hasErrors ? 'Please fill entire board with alphabetic values' : !dictionaryLoaded ? 'Loading dictionary' : 'Solve Boggle Board'}\n              type=\"submit\"\n            >\n              Run\n            </button>\n            <img\n              alt=\"logo\"\n              className={'app-logo' + ((dictionaryLoaded && !solving) ? ' --hidden' : '')}\n              src={logo}\n            />\n          </div>\n        </div>\n        {words && words.length > 0 &&\n          <React.Fragment>\n            <div>Word Count: {words.length}</div>\n            <div className=\"words\">\n              {words.join(', ')}\n            </div>\n          </React.Fragment>\n        }\n      </form>\n    </div>\n  );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}